'''
빅데이터 분석기사 공부 

02. 파이썬으로 데이터 다루기 

01. 넘파이(Numpy) 배열 다루기 
파이썬의 Numpy 패키지는 데이터 분석과 산술 연산에 사용하는 기본적인 패키지 중 하나이다.
특히, 다차원배열을 정의하고 처리하는데 필요한 다양한 기능을 제공한다. 

1) 넘파이 개요
행렬이나 대규모 다차원 배열을 쉽게 처리하도록 도와주는 파이썬 패키지 
리스트 자료형과 유사하지만, 배열의 크기가 커져도 높은 성능능 보장하며 
배열을 이용한 다양한 통계, 수학 함수도 제공한다. 
(파이썬 리스트는 배열의 크기가 커질수록 성능이 떨어짐)

리스트와 달리, 동일한 자료형만 담을 수 있다.

2) ndarray 객체
ndarray는 넘파이 패키지에 있는 다차원 배열을 지원하는 객체이다. 
ndarray는 객체는 리스트와 유사한 구조로 배열을 표현하지만, 기능적으로 더 다양한 부분을 제공한다.
다양한 메소드를 제공하여 다차원 배열을 정의한다. 

○Numpy 패키지의 추가 : import numpy as pd

○ndarray 객체 생성을 위한 주요 메소드
    array() : 리스트, 튜플 등의 데이터를 이용하여 ndarray 객체를 생성
    random.rand() : 가우시안 정규 분포를 갖는 난수(랜덤수)를 생성
    zeros() : ndarray 객체 생성 후 0으로 초기화 
    ones() : ndarray 객체 생성 후 1로 초기화
    arange() : 파이썬 내장함수 range와 동일한 기능
    reshape() : ndarray의 차원을 재구성

* 메소드 : 객체를 다룰 수 있는 함수로 객체 자체에 포함되어 정의된다. 
    - 객체명.메소드명()과 같이 메소드를 사용해서 객체를 쉽게 처리할 수 있다. 

○ ndarray 객체사용을 위한 메소드 
    sum() : 배열의 모든 요소들의 합계를 반환
    mean() : 배열의 모든 요소들의 평균값을 반환
    max() : 배열의 요소들 중 최대값 변환
    min() : 배열의 요소들 중 최소값 반환
    argmax() : 열 또는 행의 요소 중 최대값을 가지는 요소의 인덱스 반환
    argmin() : 열 또는 행의 요소 중 최소값을 가지는 요소의 인덱스 반환
    where() : 조건식에 따라 배열의 요소 값을 특정 값으로 변경
    sort() : 배열을 오름차순으로 정렬 
    

'''

# 넘파이 배열만들기 및 초기화
# 넘파이의 array() 메소드를 사용해서 배열을 생성

import numpy as np

ar1 = np.array([1,2,3,4,5])
ar2 = np.array([[1,2,3],[4,5,6]])
print(ar1)
print(ar2)

# 난수를 이용한 2차원 배열 객체 생성

import numpy as np

ar3 = np.random.randn(3) # 3크기의 1차원 배열 생성 (난수)
ar4 = np.random.randn(2,3) # 2 * 3 크기의 2차원 배열을 생성 (난수)
print(ar3)
print(ar4)

# 원소를 0 또는 1로 초기화 

import numpy as np

arg5 = np.zeros(2) # 1차원 배열로 Zero를 생성
arg6 = np.ones((2,3)) # 2차원 배열로 1이 들어간 데이터를 생성
print(arg5)
print(arg6)

# arange 와 reshape 메소드의 사용

import numpy as np 

arg7 = np.arange(20,200,10) # 20부터 200-1까지 10씩 증가
arg8 = arg7.reshape(3,6) # 3*6 배열로 재배치 
print(arg7)
print(arg8)

# 배열 다루기 
# 인덱스를 이용하여 원하는 위치의 배열 원소값을 가져오거나, 값을 변경가능
# 인덱스는 0부터 시작, a[0]은 배열의 a의 첫번째 원소, a[-1]은 마지막 원소

import numpy as np 

ar1 = np.arange(1,21,1) # 1부터 20-1까지 1씩 증가 
print(ar1) # ar 배열 전체를 프린트
print(ar1[1]) # 배열의 두번재 원소 출력 (인덱스는 0으로부터 시작)

ar2 = ar1.reshape(2,10) # 2행 10열 배열로 전환
print(ar2) # reshape된 배열을 출력
ar2[1][1] = 100 # 1행 1열을 데이터를 변경
print(ar2[1][0], ar2[1][1], ar2[1][2])

# 배열의 산술 연상 : 배열의 연산은 배열 원소에 각각 적용됨 

import numpy as np 

ar1 = np.arange(1,11,1) # 1 부터 11-1 까지 1씩 증가 
ar2 = ar1 + 3
ar3 = ar1 * 2
print(ar1)
print(ar2, "\n", ar3)

# 배열의 통계메소드 사용
# axis = 배열의 축을 지정한다. 

ar1 = np.array([[5,7,9],[-7,-6,19],[6,9,11]])

print(ar1)
print(ar1.sum()) # 배열 전체 원소의 합
print(ar1.mean()) # 배열 원소의 평균
print(ar1.max()) # 배열 원소 중 가장 큰 값
print(ar1.min()) # 배열 원소 중 가장 작은 값
print(ar1.max(axis=0)) # 배열의 각 열의 원소 중 가장 큰 값
print(ar1.max(axis=1)) # 배열의 각 행의 원소 중 가장 큰 값

# 조건식을 사용한 연산
ar1 = np.array([[5,7,9],[-7,-6,-19],[6,9,11]])
print (ar1 > 0) # ar1의 각 원소가 0보다 큰지 판단한 결과를 출력
m_count = (ar1 < 0).sum()
print(m_count)

# ar1의 원소가 0보다 작으면 0으로 변경, 그렇지 않으면 ar1의 값으로 대입

ar2 = np.where(ar1 < 0, 0, ar1) # 조건으로 데이터 치환
print(ar2)

# 배열의 정렬 
ar1 = np.array([[5,7,9],[-7,-6,-19],[6,9,11]])
print(ar1)
ar1.sort(0) # 열단위 기준으로 원소를 정렬
print(ar1)
ar1.sort(1) # 행단위 기준으로 원소를 정렬
print(ar1)

'''
02. 판다스 데이터프레임

판다스는 데이터 분석에서 가장 많이 사용하는 패키지.
넘파이가 배열 연산에 특화되어 있다면, 
판다스는 행과 열로 구성된 테이블 형식의 데이터를 다루는데 효과적이다.

1) 판다스 개요
    - 판다스는 행과 열로 이루어진 데이터를 쉽게 처리하도록 지원하는 라이브러리
    - 판다스에서 지원하는 시리즈와 데이터 프레임 객체는 다양한 자료형의 데이터를
      담을 수 있으며, 손쉽게 데이터의 결합과 분리가 가능
    - 데이터 분석에서 변수가 1개일때는 시리즈, 2개 이상일때는 데이터 프레임 사용

1. 시리즈 : 1차원 배열 형태의 구조 
    - 열의 이름을 지정할 수 있다는 점에서 파이썬 딕셔너리와 유사하다.

2. 데이터프레임 : 2차원 테이블 형태의 구조
    - 여러개의 열과 행을 가지며 각 열은 서로 다른 자료형을 가질 수 있다. 

2) 시리즈 만들고 사용하기 
    시리즈는 1차원 데이터와 인덱스로 구성되는 구조이고, 
    판다스 내장함수의 Series()를 사용한다. 

1. 시리즈 객체 생성하기
    - 판다스 시리즈는 넘파이의 ndarray의 1차원 배열을 기본으로 
      정수와 문자열 인덱스를 사용한다. 
    - 시리즈 객체 생성을 위해 Series() 함수를 사용한다.
    
import pandas as pd

sr1 = pd.Series([10,20,30,40,60])
print(sr1)

# 시리즈 객체의 값과 인덱스 확인

import pandas as pd
sr1 = pd.Series([10,30,20,40,20])
print(sr1.values) # 시리즈의 값을 출력
print(sr1.index) # 시리즈 sr1의 인덱스 값을 출력
print(sr1[2]) # 인덱스 2에 해당하는 값을 출력

# 시리즈 객체의 인덱스 설정하기 
# 인덱스를 별도로 정의 가능

import pandas as pd
sr1 = pd.Series([10,20,30,40,50], index=['a','b','c','d','e']) # 문자열 인덱스를 정의
print(sr1[1]) # 시리즈 sr[1]의 값 출력 - 숫자인덱스
print(sr1['b']) # 시리즈 sr['b']에 해당하는 인덱스 값 출력

# 원소선택 
# 인덱스를 사용하여 시리즈의 원소를 선택한다.
# 원소 하나만 선택도 되고, 여러 원소를 한꺼번에 선택하는 것도 가능하다. 

sr1 = pd.Series([10,20,30,40,50], index=['a','b','c','d','e'])
print(sr1[[1,2]]) # sr1[1], sr1[2] 값을 출력
print(sr1[['a','b']]) # sr1['a'] sr1['b'] 값 출력

# 인덱스 범위를 사용해서 원소를 선택하는 것도 가능함
# 정수형 인덱스는 끝이 포함되지 않으나, 문자열형을 포함이 됨

sr1 = pd.Series([10,20,30,40,50], index=['a','b','c','d','e'])
print(sr1[1:4]) # sr1[1], sr1[2] 값을 출력
print(sr1['a':'d']) # sr1['a'] sr1['b'] 값 출력

# 데이터프레임 만들고 사용하기

# 데이터프레임은 2차원데이터와 인덱스로 구성되는 구조이며, 
# 판다스 내장함수인 DataFrame()을 사용한다. 

# 1. 데이터프레임 객체 생성하기 
# 2차원 리스트나 딕셔너리를 사용하여 데이터프레임으로 생성할 수 있다. 

import pandas as pd

df1 = pd.DataFrame([[10,20,30],[40,50,60]])
print(df1)

# 딕셔너리를 이용한 데이터프레임 생성

import pandas as pd

dic1 = {'fruit' : ['사과','배','감','귤','바나나'],
       'price' : [100,200,150,50,200],
       'qty' : [10,25,30,20,15]}
print(dic1)
df1 = pd.DataFrame(dic1)
print(df1)

# 데이터프레임 객체의 인덱스(행)/열이름 설정하기
# 시리즈와 같이 0부터 시작하는 숫자 인덱스(기본)과 함께 문자열 인덱스를 추가로 설정할 수 있다.
# Columns 키워드를 이용하여 데이트프레임의 열이름도 설정할 수 있다.

df1 = pd.DataFrame(dic1, index = ['a','b','c','d','e'])
print(df1)

# 생성된 데이터프레임의 인덱스와 컬럼명을 변경하는 경우 rename() 메소드를 이용한다.
# inplace = True 옵션을 빼먹으면 새로운 객체를 생성해서 반환한다. 

df1.rename(columns = {'fruit' : '과일', 'price' : '가격', 'qty':'수량'}, inplace=True)
df1.rename(index = {'a':'01','b':'02','c':'03','d':'04','e':'05'}, inplace=True)
print(df1)

# 데이터 살펴보기 

# 데이터프레임 객체는 데이터프레임의 크기, 데이터 구성항목, 자료, 자료형, 통계수치 등
# 여러 정보를 확인할 수 있는 속성과 메소드를 제공함
# 대규모 외부데이터를 읽어와서 데이터프레임으로 생성한 후, 생성된 데이터 프레임의
# 내용을 잘 파악하는 것이 중요함

import pandas as pd
df1 = pd.read_csv('df_sample.csv')
df1

# 데이터셋의 첫 5개만 보기

df1.head(5)

# 데이터 요약 정보 확인하기

df1.shape # 행과 열의 개수를 확인

# info() 메소드로 데이터프레임에 관한 기본 정보를 화면에 출력

print(df1.info())

# 열별 데이터의 수를 세기 위해서 count() 메소드를 이용할 수 있다.

df1.count()

# 판다스 자료형은 대체로 파이선 기본형과 유사하지만, 시간형 데이터 정보를 제공

# 데이터프레임의 기술 통계 정보 한꺼번에 보여주기 
# include='all' 옵션을 추가하면 문자열 통계정보도 표시해줌
# 단, 문자열은 unique (고유값 개수), top(최빈값), freq(빈도수)에 대한 정보가 추가

df1.describe(include='all')

# 통계함수 적용하기 

print(df1['중간'].mean())
print(df1[['중간','기말']].mean())

# 열의 최소값, 최대값, 중간값

print(df1['학번'].min()) # 학번, 칼럼의 최소값
print(df1[['중간','기말']].max()) # 중간, 기말 컬럼의 최대값
print(df1.median()) # 칼럼별 중간값

# 열의 표준편차와 분산

print("표준편차 :")
print(df1[['중간','기말']].std())
print("분산 : ")
print(df1[['중간','기말']].var())

# 지정한 열에 포함되어 있는 고유한 값의 개수 세기
# value_counts() 메소드 사용

df1['퀴즈'].value_counts() # 퀴즈열에서 18점 3번, 14점 2번, 나머지는 각 1번씩 출현

# 상관계수 구하기 : Corr() 메소드

df1[['중간','기말']].corr() # 중간고사와 기말고사간
df1.corr() # 모든 열간의 상관계수 계산

# 데이터 프레임 조작하기 

# 특정 열을 행 인덱스로 설정 : set_index() 메소드
# '학번'과 같이 전체 행을 대표하는 열을 인덱스로 지정하는 경우에 사용
# 데이터프레임.set_index('열이름') 형태를 사용. 지정열은 인덱스 역할이므로 열 이름으로 접근하지 못함

import pandas as pd
df1 = pd.read_csv('df_sample.csv')
df1.set_index('학번') # 학번 열을 행 인덱스로 지정함

# 학번 열의 값만 읽어와서 인덱스 명으로 지정하는 방법 

df1.index = df1['학번']
df1

#reset_index() 메소드를 이용해서 행 인덱스를 정수형 위치 인덱스로 초기화 가능

# 원소 선택 
# loc 또는 iloc 인덱서를 사용하여 주어진 행 인덱스나 열이름으로 특정 원소 선택이 가능
# loc는 행인덱스와 열이름을 사용해서 선택한다. 
# iloc는 행번호와 열번호를 사용해서 선택한다.

df1.set_index('학번',inplace=True) # 학번열을 행 인덱스로 지정

print(df1.loc['S01','중간']) # 인덱스명과 열 이름을 사용해서 접근
print(df1.loc['S02','기말'])

print(df1.iloc[1,0], df1.iloc[1,1], df1.iloc[1,2]) # 인덱스 번호와 열 번호를 사용해서 접근

# inplace=True 옵션
# Set_index() 메소드에 사용하면 변경사항이 df1으로 반영된다. 
# df1 = df1.set_index('학번')과 동일

# 행 선택, 열 선택
# 인덱스명(loc)이나 인덱스번호(iloc)를 사용해서 행 전체를 선택할 수 있다.

df1.loc['S05']
df1.iloc[3]
df1['중간']

# 행과 열의 삭제 : drop() 메소드
# 주어진 행 인덱스나 열이름으로 행이나 열을 삭제할 수 있다.
# 기본설정 (axis=0)은 행을 삭제하며, 열을 삭제할때는 옵션으로 axis=1을 추가

import pandas as pd
df1 = pd.read_csv('df_sample.csv')
df2 = df1.drop(0)
df3 = df2.drop('퀴즈',axis=1) # 행삭제 필요시 axis=0으로 반영
df3

# 데이퍼프레임 정렬 (행 인덱스 기준) : sort_index() 메소드 이용
# ascending 옵션을 사용해서 오름차순 또는 내림차순 정렬 설정
# 새롭게 정렬된 데이터프레임을 반환

import pandas as pd
df1 = pd.read_csv('df_sample.csv')
df1.set_index('학번', inplace=True)   # 학번 열을 행 인덱스로 지정
df2 = df1.sort_index(ascending=False) # 학번 내림차순으로 데이터 정렬
df2 

# 데이터프레임 정렬 (특정 열 기준) : sort_values() 메소드를 이용
# ascending 옵션을 사용해서 오름차순 또는 내림차순 정렬을 설정한다. 
# 새롭게 정렬된 데이터 프레임을 반환한다. 

import pandas as pd
df1 = pd.read_csv('df_sample.csv')
df2 = df1.sort_values(by='기말', ascending=True) # 기말열을 오름차순으로 정리
df2

# 데이터 전처리

# 수집된 데이터는 분석을 위한 전처리가 필요하다. 
# 전처리 과정에는 데이터변환, 정규화, 이상치 제거, 결측치 대처 등의 작업이 포함된다. 
# 파이썬은 데이터 전처리를 위한 기능들을 제공한다. 

# 1) 데이터 변환
# 기존 데이터에서 새로운 변수를 생성하거나, 축소한 후에 분석을 진행한다.
# 변수값의 분포를 표준화하기 위해 정규화 과정을 거친다. 

# 1. 파생변수 생성
# 파생변수는 함수와 조건문 등을 통해 생김
# [], insert(), assign(), loc() 함수등으로 추가 

df1["합계"] = df1["중간"]+df1["기말"] # 중간과 기말을 정해 

x = ["1반","1반","1반","2반","2반","2반","3반","3반","3반","3반",]

# 리스트 x를 값으로 cls열을 생성하는 같은 기능의 4가지 코드 예시

df1["cls"] = x 
df1.insert(6,"cls",x,True) # 리스트 x로 df에 cls 파생변수 생성 (6은 열 위치)
df1.assign(cls=x)
# df1.loc[:,'cls'] = x
df1

# 표준화 

# 표준화는 각 데이터 값들이 평균을 기준으로 얼마나 떨어져있는지를 표현하는 값으로 변환하는 과정
# Z-score는 각 데이터 값에서 평균을 뺀 후 표준편차로 나누어준 값

import numpy as np

mid_avg = np.mean(df1["중간"])
mid_std = np.std(df1["중간"])

df1["중간_Z점수"] = (df1["중간"] - mid_avg) / mid_std

df1.head()

# 정규화 

# 정규화는 데이터의 범위를 0과 1사이로 변환하여 데이터의 분포를 조정하는 것이다. 
# (x-최소값)/(최대값-최소값) 또는 MinMaxScaler(), minmax_scale() 함수를 이용한다. 
# 상기함수는 사이킷런의 Preprocessing 패키지에서 제공하는 함수이다.

fin_min = np.min(df1["기말"]) 
fin_max = np.max(df1["기말"])

df1["기말_정규화"] = (df1["기말"] - fin_min)/(fin_max - fin_min)
df1.head()

# 데이터 요약 : 다양한 함수를 사용하여 데이터의 요약정보를 표현한다. 

# 집계함수 적용
# groupby() : 특정열을 기준으로 데이터를 그룹화하고 집계함수를 적용

df2 = df1.drop('cls',axis='columns')
df2["cls"] = x 
df2
df2_cls_grp = df2.groupby(df2['cls'])
df2_cls_grp.mean() # 그룹별 열의 평균

df2['중간'].groupby(df2['cls']).count()

# 행 또는 열에 지정한 함수 적용 : apply() 데이터의 행 또는 열 방향으로 주어진 함수를 한번에 적용

df2["퀴즈"].apply(np.sqrt)

# 결측값 처리 : NaN으로 처리되는 입력이 누락된 값. 파이썬 함수를 사용해 결츨값을 식별하고 대치 

# 결측값을 식별
# info()함수 : 칼럼별 결측값의 개수를 확인할 수 있음

x = [14,15,13,14,None,None,19,11,12,18]
df2["토론"] = x 
df2.info()

df2.isnull() # 데이터가 없으면 True, 있으면 False
df2.notnull()

# 결측값 대치
# 단순대치법 : 완전분석법, 평균대치법, 단순확률 대치법과 다중대치법이 있다.
# dropna() : 결측값이 있는 행이 제거 (완전분석법)

df2_new = df2.dropna(axis=0)
df2_new = df2["토론"].dropna()
d_mean = df2["토론"].mean()
df2["토론"].fillna(d_mean, inplace=True) # 결측값을 지정한 값으로 대체 (평균대치법)
df2

# 완전분석법 : 결측값이 있는 행을 삭제
# 평균대치법 : 결측값을 평균으로 대치
# 단순확률 대치법 : 확률 분포를 이용한 추정값으로 대치(Hot-deck) 또는 주변값으로 대치

# 4) 이상값 처리 
# 이상값은 데이터의 범위에서 크게 벗어난 값 (정상범위 밖에 있는 값)이다.
# 사분위범위, 정규분포를 이용해서 식별하고, 식별된 이상값은 제거 여부를 판단한다. 

# 이상값 식별 : 사분위수 함수 quantile(p)
# p의 값 : 0은 최소값, 1은 최대값, 0.25는 1사분위수, 0.5는 2사분위수, 0.75는 3사분위수 
# 사분위 범위 : 3사분위수 - 1사분위수 
# 이상치 판별 : (1사분위수 - 1.5*사분위범위) 보다 작거나 (3사분위수 + 1.5 * 사분위범위) 보다 큰 수

df2_1QR = df2["기말"].quantile(0.25)
df2_3QR = df2["기말"].quantile(0.75)
df2_IQR = df2_3QR - df2_1QR
print(df2_1QR)
print(df2_3QR)
print(df2_IQR)
